# ğŸ“˜ Analizador IPv4 utilizando **Flex + Bison**

Este proyecto implementa un **analizador de direcciones IPv4**, utilizando las herramientas **Flex** (para anÃ¡lisis lÃ©xico) y **Bison** (para anÃ¡lisis sintÃ¡ctico). El objetivo es enseÃ±ar y demostrar cÃ³mo ambos componentes trabajan juntos para procesar texto estructurado y detectar errores.

EstÃ¡ documentado en espaÃ±ol y con un enfoque pedagÃ³gico, como si fuera una guÃ­a para estudiantes de compiladores.

---

# ğŸ“‘ Contenido

* [ğŸ“˜ IntroducciÃ³n](#-introducciÃ³n)
* [ğŸ§© 1. Â¿QuÃ© es Flex?](#-1-quÃ©-es-flex)
* [ğŸ§© 2. Â¿QuÃ© es Bison?](#-2-quÃ©-es-bison)
* [ğŸ§  ComunicaciÃ³n Flex â†’ Bison](#-comunicaciÃ³n-flex--bison)
* [ğŸ“„ Estructura de archivos del proyecto](#-estructura-de-archivos-del-proyecto)
* [âš™ï¸ CompilaciÃ³n del proyecto](#ï¸-compilaciÃ³n-del-proyecto)
* [â–¶ï¸ EjecuciÃ³n](#ï¸-ejecuciÃ³n)
* [ğŸ§© 3. Estructura de un archivo Flex](#-3-estructura-de-un-archivo-flex)
* [ğŸ§© 4. Estructura de un archivo Bison](#-4-estructura-de-un-archivo-bison)
* [ğŸ§© 5. Manejo de errores](#-5-manejo-de-errores)
* [ğŸ§ª Ejemplos de entradas y salidas](#-ejemplos-de-entradas-y-salidas)
* [ğŸ“š ConclusiÃ³n](#-conclusiÃ³n)

---

# ğŸ“˜ IntroducciÃ³n

Flex y Bison son herramientas clÃ¡sicas para construir analizadores lÃ©xicos y sintÃ¡cticos. Se usan ampliamente en el desarrollo de compiladores, intÃ©rpretes y sistemas que necesitan interpretar contenido estructurado.

En este proyecto aprenderÃ¡s:

âœ” CÃ³mo definir tokens con expresiones regulares usando **Flex**.
âœ” CÃ³mo definir gramÃ¡ticas y acciones semÃ¡nticas usando **Bison**.
âœ” CÃ³mo pasar informaciÃ³n usando `yylval` y `%union`.
âœ” CÃ³mo manejar errores lÃ©xicos y sintÃ¡cticos correctamente.
âœ” CÃ³mo construir un analizador de **direcciones IPv4 vÃ¡lidas**.

---

# ğŸ§© 1. Â¿QuÃ© es Flex?

**Flex (Fast Lexical Analyzer)** genera un analizador lÃ©xico en lenguaje C a partir de expresiones regulares.

### Flex produce:

* Un archivo `lex.yy.c` con la funciÃ³n fundamental:

  ```c
  int yylex();
  ```
* Esta funciÃ³n devuelve tokens a Bison.

### Â¿QuÃ© hace Flex?

Convierte texto â†’ tokens.
Ejemplo:

```
192.168.0.10
```

Se convierte en:

* ENTERO
* PUNTO
* ENTERO
* PUNTO
* ENTERO
* PUNTO
* ENTERO

---

# ğŸ§© 2. Â¿QuÃ© es Bison?

**Bison** es un generador de analizadores sintÃ¡cticos. A partir de una gramÃ¡tica, produce un parser basado en reglas formales.

### Bison produce:

* `sintacticoBison.tab.c` â†’ contiene la funciÃ³n `yyparse()`
* `sintacticoBison.tab.h` â†’ contiene las definiciones de tokens

### Â¿QuÃ© hace Bison?

Convierte tokens â†’ estructura vÃ¡lida o error.

---

# ğŸ§  ComunicaciÃ³n Flex â†’ Bison

Flex y Bison se comunican mediante:

### 1. **Tokens**

Flex retorna valores que Bison reconoce:

```c
return ENTERO;
return PUNTO;
```

### 2. **Valores semÃ¡nticos (`yylval`)**

Bison define:

```yacc
%union {
    int num;
    char dir[32];
}
```

Flex asigna:

```c
yylval.num = atoi(yytext);
return ENTERO;
```

---

# ğŸ“„ Estructura de archivos del proyecto

```
.
â”œâ”€â”€ dist/                 # Archivos generados automÃ¡ticamente
â”œâ”€â”€ src/                  # CÃ³digo fuente de Flex y Bison
â”‚   â”œâ”€â”€ analex.l
â”‚   â””â”€â”€ sintacticoBison.y
â”œâ”€â”€ scripts/              # Scripts de compilaciÃ³n/ejecuciÃ³n
â”œâ”€â”€ test/                 # Archivos de prueba
â”‚   â””â”€â”€ input.txt
â””â”€â”€ README.md
```

---

# âš™ï¸ CompilaciÃ³n del proyecto

Con el Makefile incluido, solo necesitas ejecutar:

```
make
```

Esto genera:

* `dist/sintacticoBison.tab.c`
* `dist/lex.yy.c`
* `analizador` (en la raÃ­z)

---

# â–¶ï¸ EjecuciÃ³n

Para analizar un archivo:

```
./analizador < test/input.txt
```

---

# ğŸ§© 3. Estructura de un archivo Flex

Un archivo `.l` tiene esta forma:

```flex
%{
    CÃ³digo C
%}

Declaraciones y ER

%%

Reglas lÃ©xicas â†’ acciones

%%
CÃ³digo extra
```

### Ejemplo de tokenizaciÃ³n de IPv4

```flex
numero  [0-9]+
punto   \.

%%
{numero} { yylval.num = atoi(yytext); return ENTERO; }
{punto}  { return PUNTO; }
\n       { return SALTO; }
.        { return OTRO; }
%%
```

---

# ğŸ§© 4. Estructura de un archivo Bison

```yacc
%{
    CÃ³digo C
%}

%union {...}
%token ENTERO PUNTO

%%

Reglas gramaticales

%%
Funciones C
```

### Ejemplo bÃ¡sico

```yacc
expr:
      ENTERO PUNTO ENTERO
      { printf("Formato vÃ¡lido"); }
;
```

---

# ğŸ§© 5. Manejo de errores

### Error lÃ©xico (Flex)

```c
. { printf("Error lÃ©xico: %s\n", yytext); }
```

### Error sintÃ¡ctico (Bison)

```c
int yyerror(char *s) {
    printf("Error sintÃ¡ctico: %s\n", s);
}
```

### Manejo robusto de direcciones incorrectas

El parser descarta todos los tokens hasta el final de lÃ­nea para evitar errores en cascada.

---

# ğŸ§ª Ejemplos de entradas y salidas

Entrada:

```
192.168.0.10
1..3.4
300.10.20.30
```

Salida:

```
192.168.0.10 â†’ Clase C (Privada)
Error: formato invÃ¡lido (1..3.4)
Error: octeto fuera de rango (300)
```

---

# ğŸ“š ConclusiÃ³n

Este proyecto demuestra cÃ³mo Flex y Bison trabajan juntos para analizar un mini-lenguaje real: direcciones IPv4.

Conceptos clave aprendidos:

* Uso de expresiones regulares para tokenizar entradas.
* Uso de gramÃ¡ticas para validar estructuras.
* Manejo de valores con `%union` y `yylval`.
* Control de errores adecuado y no intrusivo.

Este repositorio puede servir como:

* base para construir analizadores mÃ¡s complejos,
* ejemplo didÃ¡ctico para cursos universitarios,
* plantilla para futuros proyectos con Flex + Bison.

---

Si querÃ©s extender esta guÃ­a con diagramas, flujo de tokens, ejemplos visuales o una versiÃ³n PDF, Â¡solo pedÃ­melo!
